// Minimize Malware Spread
// =======================
//
// You're given a network of n nodes as an n×n adjacency matrix graph with the ith node directly connected to the jth
// node if `graph[i][j] == 1`.
//
// A list of nodes, `initial`, is given, which contains nodes initially infected by malware. When two nodes are
// connected directly and at least one of them is infected by malware, both nodes will be infected by malware. This
// spread of malware will continue until every node in the connected component of nodes has been infected.
//
// After the infection has stopped spreading, M will represent the final number of nodes in the entire network that have
// been infected with malware.
//
// Return a node from `initial` such that, when this node is removed from the graph, M is minimized. If multiple nodes
// can be removed to minimize M, return the node with the smallest index.
//
// > Note: If a node was removed from the initial list of infected nodes, it might still be infected later on due to the
// > malware's spread.
//
// Constraints:
//
// - `graph.length` == `graph[i].length`
// - 2 ≤ n ≤ 50
// - `graph[i][j]` is 0 or 1.
// - `graph[i][j]` == `graph[j][i]`
// - `graph[i][i]` == 1
// - 1 ≤ `initial.length` ≤ n
// - 0 ≤ `initial[i]` ≤ n - 1
// - All the integers in the `initial` are unique.

using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.TestTools.UnitTesting;

namespace JatinSanghvi.CodingInterview.N26_UnionFind.P08_MinimizeMalwareSpread;

public class Solution
{
    // Time complexity: O(n^2), Space complexity: O(n).
    public static int MinMalwareSpread(int[][] graph, int[] initial)
    {
        var parents = new int[graph.Length];
        var sizes = new int[graph.Length];

        for (int i = 0; i != graph.Length; i++)
        {
            parents[i] = i;
            sizes[i] = 1;
        }

        for (int i = 0; i != graph.Length; i++)
        {
            for (int j = i + 1; j != graph.Length; j++)
            {
                if (graph[i][j] == 1)
                {
                    Union(i, j);
                }
            }
        }

        // Return minNode to satisfy the tests if there are no nodes found.
        var minNode = int.MaxValue;
        var componentNodes = new Dictionary<int, int>();
        foreach (int node in initial)
        {
            minNode = Math.Min(minNode, node);
            int comp = Find(node);
            componentNodes[comp] = componentNodes.ContainsKey(comp) ? -1 : node;
        }

        int maxSize = 0;
        int maxNode = minNode;
        foreach ((int comp, int node) in componentNodes)
        {
            if (node != -1)
            {
                int size = sizes[comp];
                if (maxSize < size || maxSize == size && maxNode > node)
                {
                    maxSize = size;
                    maxNode = node;
                }
            }
        }

        return maxNode;

        void Union(int x1, int x2)
        {
            int p1 = Find(x1);
            int p2 = Find(x2);

            if (p1 == p2) { return; }

            if (sizes[p2] > sizes[p1]) { (p1, p2) = (p2, p1); }
            parents[p2] = p1;
            sizes[p1] += sizes[p2];
        }

        int Find(int x)
        {
            if (parents[x] != x) { parents[x] = Find(parents[x]); }
            return parents[x];
        }
    }
}

internal static class Tests
{
    public static void Run()
    {
        int[][] graph =
        [
            [1, 1, 0, 0, 0],
            [1, 1, 1, 0, 0],
            [0, 1, 1, 0, 0],
            [0, 0, 0, 1, 0],
            [0, 0, 0, 0, 1],
        ];

        Run(graph, [2, 3, 4], 2);
        Run(graph, [1, 2, 3, 4], 3);
    }

    private static void Run(int[][] graph, int[] initial, int expectedResult)
    {
        int result = Solution.MinMalwareSpread(graph, initial);
        Utilities.PrintSolution((graph, initial), result);
        Assert.AreEqual(expectedResult, result);
    }
}
